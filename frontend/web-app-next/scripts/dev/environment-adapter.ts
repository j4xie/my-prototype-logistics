#!/usr/bin/env tsx
/**
 * Day 6: ç¯å¢ƒé€‚é…å·¥å…·
 * æ”¯æŒå¼€å‘/æµ‹è¯•/ç”Ÿäº§ç¯å¢ƒçš„Mocké…ç½®ç®¡ç†
 */

import fs from 'fs'
import path from 'path'

interface EnvironmentConfig {
  name: string
  mockEnabled: boolean
  apiBaseUrl: string
  mockEnvironment: string
  description: string
}

const ENVIRONMENTS: Record<string, EnvironmentConfig> = {
  development: {
    name: 'Development',
    mockEnabled: true,
    apiBaseUrl: 'http://localhost:3000/api',
    mockEnvironment: 'development',
    description: 'MSW MockæœåŠ¡å®Œå…¨å¯ç”¨ï¼Œç”¨äºæœ¬åœ°å¼€å‘'
  },
  testing: {
    name: 'Testing',
    mockEnabled: true,
    apiBaseUrl: 'http://localhost:3000/api',
    mockEnvironment: 'testing',
    description: 'MSW MockæœåŠ¡å¯ç”¨ï¼Œä½¿ç”¨æµ‹è¯•æ•°æ®é›†'
  },
  staging: {
    name: 'Staging',
    mockEnabled: false,
    apiBaseUrl: 'https://api-staging.example.com',
    mockEnvironment: 'production',
    description: 'è¿æ¥åˆ°Staging APIï¼ŒMockæœåŠ¡ç¦ç”¨'
  },
  production: {
    name: 'Production',
    mockEnabled: false,
    apiBaseUrl: 'https://api.production.com',
    mockEnvironment: 'production',
    description: 'è¿æ¥åˆ°ç”Ÿäº§APIï¼ŒMockæœåŠ¡å®Œå…¨ç¦ç”¨'
  }
}

/**
 * ç”Ÿæˆç¯å¢ƒé…ç½®æ–‡ä»¶
 */
function generateEnvFile(environment: string): string {
  const config = ENVIRONMENTS[environment]
  if (!config) {
    throw new Error(`æœªçŸ¥ç¯å¢ƒ: ${environment}`)
  }

  return `# ${config.name} Environment Configuration
# Generated by Day 6 Environment Adapter
# Date: ${new Date().toISOString()}

# Core Configuration
NODE_ENV=${environment}
NEXT_PUBLIC_API_BASE_URL=${config.apiBaseUrl}

# MSW Mock Configuration (Day 6 Migration)
NEXT_PUBLIC_MOCK_ENABLED=${config.mockEnabled}
NEXT_PUBLIC_MOCK_ENVIRONMENT=${config.mockEnvironment}

# Environment Description
# ${config.description}

# Day 6 Migration Notes:
# - All App Router APIs have been migrated to MSW
# - Mock data is centrally managed through MSW system
# - Version management ensures schema consistency
# - Use 'npm run mock:status' to verify configuration
`
}

/**
 * åº”ç”¨ç¯å¢ƒé…ç½®
 */
function applyEnvironment(environment: string): void {
  try {
    const envContent = generateEnvFile(environment)
    const envPath = path.join(process.cwd(), '.env.local')

    // å¤‡ä»½ç°æœ‰é…ç½®
    if (fs.existsSync(envPath)) {
      const backupPath = `${envPath}.backup.${Date.now()}`
      fs.copyFileSync(envPath, backupPath)
      console.log(`ğŸ“ å¤‡ä»½ç°æœ‰é…ç½®: ${backupPath}`)
    }

    // å†™å…¥æ–°é…ç½®
    fs.writeFileSync(envPath, envContent)
    console.log(`âœ… ç¯å¢ƒé…ç½®å·²æ›´æ–°: ${environment}`)
    console.log(`ğŸ“„ é…ç½®æ–‡ä»¶: .env.local`)

    // æ˜¾ç¤ºé…ç½®è¯¦æƒ…
    const config = ENVIRONMENTS[environment]
    console.log(`\nğŸ“Š ç¯å¢ƒè¯¦æƒ…:`)
    console.log(`åç§°: ${config.name}`)
    console.log(`Mockå¯ç”¨: ${config.mockEnabled ? 'æ˜¯' : 'å¦'}`)
    console.log(`APIåœ°å€: ${config.apiBaseUrl}`)
    console.log(`æè¿°: ${config.description}`)

  } catch (error) {
    console.error(`âŒ ç¯å¢ƒé…ç½®å¤±è´¥:`, error)
    process.exit(1)
  }
}

/**
 * æ˜¾ç¤ºå½“å‰ç¯å¢ƒçŠ¶æ€
 */
function showCurrentEnvironment(): void {
  const envPath = path.join(process.cwd(), '.env.local')

  console.log('\nğŸŒ å½“å‰ç¯å¢ƒçŠ¶æ€')
  console.log('=' .repeat(50))

  if (!fs.existsSync(envPath)) {
    console.log('âŒ æœªæ‰¾åˆ° .env.local æ–‡ä»¶')
    console.log('ğŸ’¡ ä½¿ç”¨ --apply <environment> åˆ›å»ºé…ç½®')
    return
  }

  try {
    const content = fs.readFileSync(envPath, 'utf-8')
    const lines = content.split('\n')

    let nodeEnv = 'unknown'
    let mockEnabled = 'unknown'
    let apiBaseUrl = 'unknown'

    for (const line of lines) {
      if (line.startsWith('NODE_ENV=')) {
        nodeEnv = line.split('=')[1]
      } else if (line.startsWith('NEXT_PUBLIC_MOCK_ENABLED=')) {
        mockEnabled = line.split('=')[1]
      } else if (line.startsWith('NEXT_PUBLIC_API_BASE_URL=')) {
        apiBaseUrl = line.split('=')[1]
      }
    }

    console.log(`ç¯å¢ƒ: ${nodeEnv}`)
    console.log(`Mockå¯ç”¨: ${mockEnabled}`)
    console.log(`APIåœ°å€: ${apiBaseUrl}`)

    // æ£€æŸ¥é…ç½®æœ‰æ•ˆæ€§
    if (ENVIRONMENTS[nodeEnv]) {
      const expectedConfig = ENVIRONMENTS[nodeEnv]
      const isValid =
        mockEnabled === expectedConfig.mockEnabled.toString() &&
        apiBaseUrl === expectedConfig.apiBaseUrl

      console.log(`é…ç½®çŠ¶æ€: ${isValid ? 'âœ… æœ‰æ•ˆ' : 'âš ï¸ ä¸åŒ¹é…'}`)

      if (!isValid) {
        console.log(`\nğŸ’¡ å»ºè®®è¿è¡Œ: npm run env:apply ${nodeEnv}`)
      }
    }

  } catch (error) {
    console.error('âŒ è¯»å–ç¯å¢ƒé…ç½®å¤±è´¥:', error)
  }
}

/**
 * æ˜¾ç¤ºæ‰€æœ‰å¯ç”¨ç¯å¢ƒ
 */
function listEnvironments(): void {
  console.log('\nğŸŒ å¯ç”¨ç¯å¢ƒé…ç½®')
  console.log('=' .repeat(50))

  for (const [key, config] of Object.entries(ENVIRONMENTS)) {
    console.log(`\nğŸ“‹ ${key}`)
    console.log(`  åç§°: ${config.name}`)
    console.log(`  Mock: ${config.mockEnabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`)
    console.log(`  API: ${config.apiBaseUrl}`)
    console.log(`  è¯´æ˜: ${config.description}`)
  }

  console.log(`\nğŸ’¡ ä½¿ç”¨æ–¹æ³•: npm run env:apply <environment>`)
}

/**
 * éªŒè¯ç¯å¢ƒé…ç½®
 */
async function validateEnvironment(): Promise<void> {
  console.log('\nğŸ” éªŒè¯ç¯å¢ƒé…ç½®')
  console.log('=' .repeat(50))

  try {
    // æ£€æŸ¥ç¯å¢ƒå˜é‡
    const mockEnabled = process.env.NEXT_PUBLIC_MOCK_ENABLED === 'true'
    const apiBaseUrl = process.env.NEXT_PUBLIC_API_BASE_URL

    console.log(`Mockå¯ç”¨: ${mockEnabled}`)
    console.log(`APIåœ°å€: ${apiBaseUrl}`)

    if (mockEnabled) {
      // æµ‹è¯•MSWçŠ¶æ€
      console.log('\nğŸ§ª æµ‹è¯•MSWæœåŠ¡...')
      try {
        const response = await fetch(`${apiBaseUrl}/users/profile`)
        if (response.ok) {
          console.log('âœ… MSWæœåŠ¡æ­£å¸¸')
        } else if (response.status === 410) {
          console.log('âœ… App Router APIå·²è¿ç§»åˆ°MSW (410çŠ¶æ€æ­£å¸¸)')
        } else {
          console.log(`âš ï¸ MSWå“åº”å¼‚å¸¸: ${response.status}`)
        }
      } catch (error) {
        console.log(`âŒ MSWæœåŠ¡ä¸å¯ç”¨: ${error}`)
      }
    } else {
      console.log('â„¹ï¸ MockæœåŠ¡å·²ç¦ç”¨ï¼Œå°†ä½¿ç”¨å¤–éƒ¨API')
    }

  } catch (error) {
    console.error('âŒ ç¯å¢ƒéªŒè¯å¤±è´¥:', error)
  }
}

/**
 * ä¸»å‡½æ•°
 */
async function main() {
  const args = process.argv.slice(2)

  if (args.includes('--help') || args.length === 0) {
    console.log('\nğŸŒ ç¯å¢ƒé€‚é…å·¥å…· (Day 6)')
    console.log('=' .repeat(50))
    console.log('å‘½ä»¤:')
    console.log('  --list       åˆ—å‡ºæ‰€æœ‰å¯ç”¨ç¯å¢ƒ')
    console.log('  --status     æ˜¾ç¤ºå½“å‰ç¯å¢ƒçŠ¶æ€')
    console.log('  --apply <env> åº”ç”¨æŒ‡å®šç¯å¢ƒé…ç½®')
    console.log('  --validate   éªŒè¯å½“å‰ç¯å¢ƒé…ç½®')
    console.log('  --help       æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯')
    console.log('\nå¯ç”¨ç¯å¢ƒ: development, testing, staging, production')
    return
  }

  if (args.includes('--list')) {
    listEnvironments()
  }

  if (args.includes('--status')) {
    showCurrentEnvironment()
  }

  if (args.includes('--validate')) {
    await validateEnvironment()
  }

  const applyIndex = args.indexOf('--apply')
  if (applyIndex !== -1 && args[applyIndex + 1]) {
    const environment = args[applyIndex + 1]
    if (ENVIRONMENTS[environment]) {
      applyEnvironment(environment)
    } else {
      console.error(`âŒ æœªçŸ¥ç¯å¢ƒ: ${environment}`)
      console.log('å¯ç”¨ç¯å¢ƒ:', Object.keys(ENVIRONMENTS).join(', '))
      process.exit(1)
    }
  }
}

// æ‰§è¡Œä¸»å‡½æ•°
main().catch(console.error)
