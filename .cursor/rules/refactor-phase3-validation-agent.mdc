---
description: 
globs: 
alwaysApply: false
---
# Phase-3 验证流程代理规则

## 🎯 **Phase-3验证文档结构指导**

### **验证状态记录原则**
**状态更新优先级**: 
1. **第一优先**: 更新 `refactor/phase-3/PHASE-3-MASTER-STATUS.md` (单一权威来源)
2. **第二优先**: 更新具体任务文档 (如 TASK-P3-016A-真实状态追踪.md)
3. **引用同步**: 确保其他文档通过引用保持一致

### **验证结果记录标准**
```bash
# 验证完成后必须执行的文档更新
1. 更新PHASE-3-MASTER-STATUS.md中的验证状态字段
2. 更新核心状态概览中的完成度
3. 记录具体验证结果到"重要状态变更记录"
4. 更新"快速状态查询"中的可做/不可做事项
5. 生成或更新验证报告到scripts/validation/目录
```

### **质疑响应文档协议**
当用户质疑时，验证结果必须首先体现在MASTER-STATUS文档中，然后其他详细文档通过引用方式保持一致。

## 使用场景
- Phase-3技术栈现代化的验证阶段
- 需要深度功能验证和核心组件测试
- 用户质疑完成度需要重新验证
- 防止过度乐观报告和验证盲区
- 确保关键组件功能正常

## 🔍 **分层验证流程强制执行** (基于Phase-3实际问题经验)

### **5层验证标准** (必须按顺序完成)
```bash
第1层: TypeScript编译检查
- [ ] tsc --noEmit 通过 (0错误)
- [ ] 所有导入都被解析
- [ ] 所有类型定义正确
- [ ] 接口和类型兼容性验证

第2层: 构建系统验证
- [ ] npm run build 成功 (0错误)
- [ ] 生产构建完整无缺失
- [ ] 静态资源正确生成
- [ ] 构建产物大小合理

第3层: 代码质量检查
- [ ] ESLint检查通过 (警告<10个)
- [ ] 所有导入都被使用 (无未使用导入)
- [ ] 所有变量都被使用 (无未使用变量)
- [ ] 代码风格一致性检查

第4层: 核心功能验证 + 回归测试 ⭐ **关键增强**
- [ ] **全量测试执行**: npm test (所有测试套件)
- [ ] **回归基线检查**: 确保之前通过的测试依然通过
- [ ] **性能回归检查**: 内存使用、执行时间无明显回退
- [ ] **功能完整性验证**: 关键Hook和API功能正常
- [ ] **错误处理回归**: 之前修复的错误处理依然有效

第5层: 集成功能验证 + 端到端回归
- [ ] npm run dev 正常启动
- [ ] **页面功能回归**: 核心页面和用户流程正常
- [ ] **API集成回归**: 之前修复的API调用依然稳定
- [ ] **状态管理回归**: useApi、离线队列等核心功能稳定
- [ ] **错误恢复回归**: 网络异常、内存问题处理机制正常
```

### **验证命令执行标准**
```bash
# 第1层验证命令
npx tsc --noEmit
# 预期结果: 无任何错误输出

# 第2层验证命令
npm run build
# 预期结果: 构建成功，生成 .next 目录

# 第3层验证命令
npm run lint
# 预期结果: 无错误，警告数量<10个

# 第4层验证命令 (需要实际测试)
npm run test:unit
# 预期结果: 所有单元测试通过

# 第5层验证命令
npm run dev
# 预期结果: 服务正常启动，端口可访问
```

## 🎯 **核心组件特别验证规则** (防止关键组件验证盲区)

### **关键组件清单**
```typescript
// 必须进行功能验证的核心组件清单
const CRITICAL_COMPONENTS = [
  // API和网络层
  'src/hooks/useApi.ts',       // API客户端Hook - 最高优先级 (包含useSimpleApi)
  'src/lib/api-client.ts',     // API客户端核心
  'src/lib/offline-queue.ts',  // 离线队列管理
  
  // 认证和状态管理
  'src/hooks/useAuth.ts',      // 认证Hook (内置于useApi.ts中)
  'src/store/index.ts',        // 状态管理中心
  'src/store/auth.ts',         // 认证状态
  
  // 配置和环境
  'src/config/app.ts',         // 应用配置
  'src/config/api.ts',         // API配置
  
  // 核心页面组件
  'src/app/layout.tsx',        // 根布局组件
  'src/app/page.tsx',          // 首页组件
  'src/components/ui/layout.tsx' // UI布局组件
];
```

### **核心组件验证标准**
```typescript
// 对每个核心组件的验证要求

1. **导入验证**
- ✅ 组件可以正常导入
- ✅ 所有依赖都能正确解析
- ✅ 类型定义完整无错误

2. **实际调用测试**
- ✅ 函数/Hook可以实际调用
- ✅ 返回值类型正确
- ✅ 异步操作正常完成

3. **错误场景覆盖**
- ✅ 网络异常处理正确
- ✅ 参数错误处理完整
- ✅ 边界条件处理合理

4. **状态一致性验证**
- ✅ 状态变更逻辑正确
- ✅ 副作用处理完整
- ✅ 内存泄漏检查通过

5. **性能基准验证**
- ✅ 核心操作在合理时间内完成
- ✅ 内存使用在预期范围内
- ✅ 无明显性能回归
```

### **useApi Hook特别验证** (基于实际问题经验)
```typescript
// useApi Hook的深度验证清单
const useApiValidation = {
  // 基础功能验证
  basicFunctionality: [
    '✅ Hook可以正常导入和调用',
    '✅ 返回正确的状态对象 (data, loading, error)',
    '✅ 支持GET/POST/PUT/DELETE方法',
    '✅ 请求参数正确传递'
  ],
  
  // 状态管理验证
  stateManagement: [
    '✅ loading状态正确切换',
    '✅ 成功响应正确设置data',
    '✅ 错误响应正确设置error',
    '✅ 重复请求处理正确'
  ],
  
  // 错误处理验证
  errorHandling: [
    '✅ 网络错误正确捕获',
    '✅ HTTP错误状态正确处理',
    '✅ 超时错误正确处理',
    '✅ 取消请求功能正常'
  ],
  
  // 性能和内存验证
  performance: [
    '✅ 组件卸载时正确清理',
    '✅ 无内存泄漏',
    '✅ 请求去重机制正常',
    '✅ 缓存机制工作正常'
  ]
};
```

## 🔄 **回归测试协议** (防止已修复问题重新出现)

### **回归风险评估矩阵**
```bash
# 基于TASK-P3-016A实际经验的风险分类
高风险回归场景:
🚨 P0: Jest配置修改 → 可能重新引入内存泄漏
🚨 P0: useApi Hook调整 → 可能破坏已修复的无限循环
🚨 P0: 测试环境变更 → 可能导致已通过测试失效

中风险回归场景:
⚠️ P1: 依赖包更新 → 可能影响TypeScript编译
⚠️ P1: 构建配置调整 → 可能破坏构建稳定性
⚠️ P1: ESLint规则变更 → 可能引入新的代码质量问题

低风险回归场景:
🟡 P2: 文档更新 → 通常不影响功能
🟡 P2: 样式调整 → 影响范围可控
🟡 P2: 注释修改 → 不影响运行时行为
```

### **回归测试基线管理**
```javascript
// 回归测试基线记录
const REGRESSION_BASELINE = {
  // 基于当前TASK-P3-016A状态
  testSuiteBaseline: {
    totalTests: 33,
    passingTests: 26,
    failingTests: 7,
    passRate: 78.8,
    criticalTests: [
      'useApi Hook基础功能',
      'SyncManager核心逻辑', 
      'OfflineQueue队列管理',
      '内存泄漏防护',
      'TypeScript编译检查'
    ]
  },
  
  performanceBaseline: {
    buildTime: '29.5s',
    devStartupTime: '2s',
    memoryUsage: 'stable (no heap overflow)',
    testExecutionTime: 'under 60s'
  },
  
  functionalBaseline: {
    coreHooks: ['useApi', 'useAuth', 'useSync'],
    apiEndpoints: ['/api/auth', '/api/data', '/api/sync'],
    errorHandling: ['network failure', 'timeout', 'auth error'],
    stateManagement: ['loading states', 'error states', 'success states']
  }
};
```

### **强制回归检查流程**
```bash
# 每次验证必须执行的回归检查

步骤1: 基线对比检查
- [ ] 对比当前测试结果与上次基线
- [ ] 识别测试通过率是否下降
- [ ] 检查关键功能测试是否失效
- [ ] 验证性能指标是否回退

步骤2: 风险点重点验证  
- [ ] 重新测试之前修复的P0问题
- [ ] 确认内存泄漏问题未重现
- [ ] 验证Jest配置依然优化有效
- [ ] 检查useApi Hook稳定性

步骤3: 全量功能回归
- [ ] 执行完整测试套件 (不只是增量测试)
- [ ] 验证所有关键用户流程
- [ ] 确认错误处理机制完整
- [ ] 检查状态管理一致性

步骤4: 性能回归验证
- [ ] 构建时间未明显增加
- [ ] 开发服务器启动时间稳定
- [ ] 内存使用模式正常
- [ ] 无新的性能瓶颈引入

步骤5: 回归报告生成
- [ ] 记录所有回归检查结果
- [ ] 标识发现的回归问题
- [ ] 提供回归修复建议
- [ ] 更新回归基线数据
```

### **TASK-P3-016A专项回归检查清单**
```markdown
## 针对当前任务的特殊回归要求

### 内存管理回归检查 ⭐ **最高优先级**
- [ ] Jest maxWorkers=2 配置依然有效
- [ ] workerIdleMemoryLimit=512MB 限制正常
- [ ] --max-old-space-size=8192 设置保持
- [ ] 无 "JavaScript heap out of memory" 错误

### useApi Hook功能回归检查
- [ ] 无限循环问题未重现
- [ ] retryDelay参数正确工作
- [ ] mutate函数类型正确
- [ ] ESLint禁用注释保持有效

### 测试环境稳定性回归
- [ ] 26个已通过测试依然通过
- [ ] SyncManager批量处理测试稳定
- [ ] 网络状态回调测试正常
- [ ] 并发控制测试无回退

### 构建系统回归检查
- [ ] TypeScript编译0错误保持
- [ ] 构建29.5秒时间稳定
- [ ] ESLint检查通过保持
- [ ] 开发服务器2秒启动保持
```

## 🚨 **用户质疑响应协议** (标准重验流程)

### **质疑响应标准流程**
```markdown
当用户质疑完成度时，立即执行以下步骤：

步骤1: **承认可能过于乐观** (必须执行)
- 回应: "您的质疑很有道理，让我重新进行深度验证"
- 暂停: 停止基于理论分析的任何完成度声明
- 记录: 记录用户具体质疑的功能点

步骤2: **执行完整分层验证** (从第1层开始)
- 重新执行: 从TypeScript编译开始的完整5层验证
- 实时报告: 每层验证结果实时反馈给用户
- 问题记录: 详细记录每个发现的问题

步骤3: **核心组件重点验证** (特别关注用户提到的功能)
- 针对性测试: 重点验证用户质疑的具体组件
- 实际调用: 进行真实的功能调用测试
- 场景覆盖: 测试正常和异常场景

步骤4: **如实报告结果** (基于实际验证结果)
- 问题清单: 列出所有发现的问题
- 状态修正: 基于实际情况修正完成度
- 解决方案: 提供具体的问题解决方案

步骤5: **修正相关文档** (确保信息一致性)
- 状态更新: 更新所有包含错误完成度的文档
- 问题记录: 在相关任务文档中记录发现的问题
- 经验总结: 总结验证盲区和改进措施

步骤6: **建立持续验证机制** (防止问题再次发生)
- 验证频率: 建立定期验证机制
- 自动化检查: 设置自动化验证脚本
- 质量门禁: 强化质量门禁标准
```

### **质疑响应模板**
```markdown
## 用户质疑响应报告

### 质疑内容记录
- **质疑时间**: [时间戳]
- **质疑内容**: [用户具体质疑的功能或问题]
- **原始声明**: [之前声称的完成状态]

### 重新验证结果
- **第1层验证**: [TypeScript编译结果]
- **第2层验证**: [构建系统结果]
- **第3层验证**: [代码质量检查结果]
- **第4层验证**: [核心功能验证结果]
- **第5层验证**: [集成功能验证结果]

### 发现的问题
- **P0问题**: [阻塞级问题列表]
- **P1问题**: [高优先级问题列表]
- **P2问题**: [中优先级问题列表]

### 修正后的状态
- **实际完成度**: [基于验证结果的真实完成度]
- **剩余工作**: [需要完成的具体工作]
- **预期时间**: [完成剩余工作的预期时间]

### 改进措施
- **验证盲区**: [识别出的验证盲区]
- **流程改进**: [验证流程的改进措施]
- **预防机制**: [防止类似问题的机制]
```

## 🔧 **自动化验证脚本**

### **验证脚本模板**
```bash
#!/bin/bash
# Phase-3 完整验证脚本

echo "🔍 开始Phase-3完整验证流程..."

# 第1层: TypeScript编译检查
echo "📝 第1层: TypeScript编译检查"
npx tsc --noEmit
if [ $? -ne 0 ]; then
  echo "❌ TypeScript编译失败"
  exit 1
fi
echo "✅ TypeScript编译通过"

# 第2层: 构建系统验证
echo "🏗️ 第2层: 构建系统验证"
npm run build
if [ $? -ne 0 ]; then
  echo "❌ 构建失败"
  exit 1
fi
echo "✅ 构建成功"

# 第3层: 代码质量检查
echo "🔍 第3层: 代码质量检查"
npm run lint
if [ $? -ne 0 ]; then
  echo "⚠️ ESLint检查发现问题"
fi

# 第4层: 核心功能验证
echo "🎯 第4层: 核心功能验证"
npm run test:unit
if [ $? -ne 0 ]; then
  echo "❌ 单元测试失败"
  exit 1
fi
echo "✅ 核心功能验证通过"

# 第5层: 集成功能验证
echo "🔗 第5层: 集成功能验证"
timeout 30s npm run dev &
DEV_PID=$!
sleep 10
if curl -f http://localhost:3000 > /dev/null 2>&1; then
  echo "✅ 开发服务器正常启动"
else
  echo "❌ 开发服务器启动失败"
fi
kill $DEV_PID

echo "🎉 Phase-3验证流程完成"
```

## 关键规则
- 必须按5层验证标准顺序执行，不允许跳过
- 核心组件必须进行实际调用测试，不能只检查导入
- 用户质疑时立即启动标准重验流程
- 所有验证结果必须如实记录和报告
- 发现问题必须立即修正状态和文档

## 示例

<example>
**正确的验证流程执行**：

1. **系统性验证**：
   ```bash
   # 按顺序执行5层验证
   npx tsc --noEmit        # 第1层
   npm run build           # 第2层
   npm run lint            # 第3层
   npm run test:unit       # 第4层
   npm run dev             # 第5层
   ```

2. **核心组件验证**：
   ```typescript
   // 实际调用useApi Hook
   const { data, loading, error } = useApi('/api/test');
   
   // 验证状态变化
   expect(loading).toBe(true);
   await waitFor(() => expect(data).toBeDefined());
   ```

3. **问题发现和处理**：
   - 发现构建错误立即修复
   - 更新相关文档状态
   - 记录问题和解决方案
</example>

<example type="invalid">
**错误的验证方式**：

1. **跳过验证层次**：
   - 只检查构建不检查TypeScript
   - 忽略ESLint警告
   - 不进行实际功能测试

2. **表面验证**：
   - 只检查文件是否存在
   - 不进行实际调用测试
   - 忽视错误场景

3. **质疑响应不当**：
   - 坚持原有判断不重新验证
   - 基于理论分析反驳用户质疑
   - 不修正错误的完成度声明
</example>





