package com.cretas.aims.service;

import com.cretas.aims.entity.MaterialBatch;
import com.cretas.aims.entity.MaterialBatchAdjustment;
import com.cretas.aims.entity.ProductionPlanBatchUsage;
import com.cretas.aims.repository.MaterialBatchAdjustmentRepository;
import com.cretas.aims.repository.MaterialBatchRepository;
import com.cretas.aims.repository.ProductionPlanBatchUsageRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * 原料批次管理服务
 *
 * 核心功能：
 * 1. CRUD操作（创建、查询、更新、删除、批量创建）
 * 2. 材料流转（预留、释放、消耗）
 * 3. FIFO库存分配算法
 * 4. 过期批次自动处理
 * 5. 库存统计（数量、金额、周转率）
 * 6. 低库存预警
 * 7. 调整记录管理
 *
 * @author Claude (AI Assistant)
 * @date 2025-11-18
 */
@Slf4j
@Service
public class MaterialBatchService {

    @Autowired
    private MaterialBatchRepository batchRepository;

    @Autowired
    private MaterialBatchAdjustmentRepository adjustmentRepository;

    @Autowired
    private ProductionPlanBatchUsageRepository usageRepository;

    // ========== CRUD操作 ==========

    /**
     * 创建原料批次
     */
    @Transactional
    public MaterialBatch createBatch(MaterialBatch batch, Integer createdBy) {
        log.info("创建原料批次: factoryId={}, batchNumber={}, materialTypeId={}",
                batch.getFactoryId(), batch.getBatchNumber(), batch.getMaterialTypeId());

        // 设置创建人
        batch.setCreatedBy(createdBy);

        // 初始化剩余数量 = 入库数量
        if (batch.getRemainingQuantity() == null) {
            batch.setRemainingQuantity(batch.getInboundQuantity());
        }

        // 计算总成本
        if (batch.getTotalCost() == null && batch.getInboundQuantity() != null && batch.getUnitPrice() != null) {
            batch.setTotalCost(batch.getInboundQuantity().multiply(batch.getUnitPrice()));
        }

        // 检查批次号唯一性
        if (batchRepository.findByBatchNumber(batch.getBatchNumber()).isPresent()) {
            throw new RuntimeException("批次号已存在: " + batch.getBatchNumber());
        }

        MaterialBatch saved = batchRepository.save(batch);
        log.info("原料批次创建成功: id={}, batchNumber={}", saved.getId(), saved.getBatchNumber());

        return saved;
    }

    /**
     * 批量创建原料批次
     */
    @Transactional
    public List<MaterialBatch> batchCreateBatches(List<MaterialBatch> batches, Integer createdBy) {
        log.info("批量创建原料批次: count={}", batches.size());

        List<MaterialBatch> savedBatches = new ArrayList<>();

        for (MaterialBatch batch : batches) {
            try {
                MaterialBatch saved = createBatch(batch, createdBy);
                savedBatches.add(saved);
            } catch (Exception e) {
                log.error("批量创建失败, batchNumber={}, error={}", batch.getBatchNumber(), e.getMessage());
                // 继续处理其他批次
            }
        }

        log.info("批量创建完成: 成功={}, 失败={}", savedBatches.size(), batches.size() - savedBatches.size());
        return savedBatches;
    }

    /**
     * 根据ID获取批次
     */
    public MaterialBatch getBatchById(String batchId) {
        return batchRepository.findById(batchId)
                .orElseThrow(() -> new RuntimeException("批次不存在: " + batchId));
    }

    /**
     * 根据批次号获取批次
     */
    public MaterialBatch getBatchByNumber(String batchNumber) {
        return batchRepository.findByBatchNumber(batchNumber)
                .orElseThrow(() -> new RuntimeException("批次号不存在: " + batchNumber));
    }

    /**
     * 分页获取工厂批次列表
     */
    public Page<MaterialBatch> getBatchesByFactory(String factoryId, Pageable pageable) {
        return batchRepository.findByFactoryId(factoryId, pageable);
    }

    /**
     * 根据状态获取批次
     */
    public List<MaterialBatch> getBatchesByStatus(String factoryId, MaterialBatch.BatchStatus status) {
        return batchRepository.findByFactoryIdAndStatus(factoryId, status);
    }

    /**
     * 根据材料类型获取批次
     */
    public List<MaterialBatch> getBatchesByMaterialType(String factoryId, String materialTypeId) {
        return batchRepository.findByFactoryIdAndMaterialTypeId(factoryId, materialTypeId);
    }

    /**
     * 更新批次信息
     */
    @Transactional
    public MaterialBatch updateBatch(String batchId, MaterialBatch updates) {
        MaterialBatch existing = getBatchById(batchId);

        log.info("更新批次信息: batchId={}, batchNumber={}", batchId, existing.getBatchNumber());

        // 更新可修改的字段
        if (updates.getUnitPrice() != null) {
            existing.setUnitPrice(updates.getUnitPrice());
            // 重新计算总成本
            existing.setTotalCost(existing.getInboundQuantity().multiply(updates.getUnitPrice()));
        }

        if (updates.getSupplierId() != null) {
            existing.setSupplierId(updates.getSupplierId());
        }

        if (updates.getExpiryDate() != null) {
            existing.setExpiryDate(updates.getExpiryDate());
        }

        if (updates.getProductionDate() != null) {
            existing.setProductionDate(updates.getProductionDate());
        }

        if (updates.getQualityGrade() != null) {
            existing.setQualityGrade(updates.getQualityGrade());
        }

        if (updates.getQualityReport() != null) {
            existing.setQualityReport(updates.getQualityReport());
        }

        if (updates.getStorageLocation() != null) {
            existing.setStorageLocation(updates.getStorageLocation());
        }

        if (updates.getNotes() != null) {
            existing.setNotes(updates.getNotes());
        }

        return batchRepository.save(existing);
    }

    /**
     * 删除批次
     */
    @Transactional
    public void deleteBatch(String batchId) {
        MaterialBatch batch = getBatchById(batchId);

        // 检查是否可删除（没有预留或使用记录）
        if (batch.getReservedQuantity().compareTo(BigDecimal.ZERO) > 0) {
            throw new RuntimeException("批次有预留数量，无法删除: " + batch.getBatchNumber());
        }

        if (batch.getUsedQuantity().compareTo(BigDecimal.ZERO) > 0) {
            throw new RuntimeException("批次已有使用记录，无法删除: " + batch.getBatchNumber());
        }

        log.info("删除批次: batchId={}, batchNumber={}", batchId, batch.getBatchNumber());
        batchRepository.delete(batch);
    }

    // ========== 材料流转操作 ==========

    /**
     * 预留批次材料（创建生产计划时）
     */
    @Transactional
    public void reserveBatch(String batchId, BigDecimal quantity, String productionPlanId) {
        MaterialBatch batch = getBatchById(batchId);

        log.info("预留批次材料: batchId={}, quantity={}, planId={}",
                batchId, quantity, productionPlanId);

        // 调用实体类的预留方法
        boolean success = batch.reserve(quantity);

        if (!success) {
            throw new RuntimeException("批次可用数量不足，无法预留: " + batch.getBatchNumber() +
                    ", 需要=" + quantity + ", 可用=" + batch.getAvailableQuantity());
        }

        // 保存批次更新
        batchRepository.save(batch);

        // 创建生产计划批次使用记录
        ProductionPlanBatchUsage usage = new ProductionPlanBatchUsage(
                productionPlanId, batchId, quantity, batch.getUnitPrice());
        usageRepository.save(usage);

        log.info("预留成功: batchId={}, 剩余数量={}, 预留数量={}",
                batchId, batch.getRemainingQuantity(), batch.getReservedQuantity());
    }

    /**
     * 释放预留的材料（取消生产计划时）
     */
    @Transactional
    public void releaseBatch(String batchId, BigDecimal quantity, String productionPlanId) {
        MaterialBatch batch = getBatchById(batchId);

        log.info("释放预留材料: batchId={}, quantity={}, planId={}",
                batchId, quantity, productionPlanId);

        // 调用实体类的释放方法
        boolean success = batch.release(quantity);

        if (!success) {
            throw new RuntimeException("批次预留数量不足，无法释放: " + batch.getBatchNumber() +
                    ", 需要=" + quantity + ", 预留=" + batch.getReservedQuantity());
        }

        // 保存批次更新
        batchRepository.save(batch);

        // 删除生产计划批次使用记录
        usageRepository.findByProductionPlanIdAndMaterialBatchId(productionPlanId, batchId)
                .ifPresent(usageRepository::delete);

        log.info("释放成功: batchId={}, 剩余数量={}, 预留数量={}",
                batchId, batch.getRemainingQuantity(), batch.getReservedQuantity());
    }

    /**
     * 消耗批次材料（生产完成时，从预留中消耗）
     */
    @Transactional
    public void consumeBatch(String batchId, BigDecimal quantity, String productionPlanId) {
        MaterialBatch batch = getBatchById(batchId);

        log.info("消耗批次材料: batchId={}, quantity={}, planId={}",
                batchId, quantity, productionPlanId);

        // 调用实体类的消耗方法
        boolean success = batch.consume(quantity);

        if (!success) {
            throw new RuntimeException("批次预留数量不足，无法消耗: " + batch.getBatchNumber() +
                    ", 需要=" + quantity + ", 预留=" + batch.getReservedQuantity());
        }

        // 保存批次更新
        batchRepository.save(batch);

        // 更新生产计划批次使用记录的实际数量
        usageRepository.findByProductionPlanIdAndMaterialBatchId(productionPlanId, batchId)
                .ifPresent(usage -> {
                    usage.setActualUsage(quantity);
                    usageRepository.save(usage);
                });

        log.info("消耗成功: batchId={}, 剩余数量={}, 已使用={}, 预留={}",
                batchId, batch.getRemainingQuantity(), batch.getUsedQuantity(), batch.getReservedQuantity());
    }

    /**
     * 直接使用批次材料（不通过预留，直接消耗）
     */
    @Transactional
    public void useBatch(String batchId, BigDecimal quantity, String productionPlanId) {
        MaterialBatch batch = getBatchById(batchId);

        log.info("直接使用批次材料: batchId={}, quantity={}, planId={}",
                batchId, quantity, productionPlanId);

        // 调用实体类的使用方法
        boolean success = batch.use(quantity);

        if (!success) {
            throw new RuntimeException("批次可用数量不足: " + batch.getBatchNumber() +
                    ", 需要=" + quantity + ", 可用=" + batch.getAvailableQuantity());
        }

        // 保存批次更新
        batchRepository.save(batch);

        // 如果有生产计划ID，创建使用记录
        if (productionPlanId != null) {
            ProductionPlanBatchUsage usage = new ProductionPlanBatchUsage(
                    productionPlanId, batchId, quantity, batch.getUnitPrice());
            usage.setActualUsage(quantity); // 直接使用，实际数量=计划数量
            usageRepository.save(usage);
        }

        log.info("使用成功: batchId={}, 剩余数量={}, 已使用={}",
                batchId, batch.getRemainingQuantity(), batch.getUsedQuantity());
    }

    /**
     * 调整批次数量（库存盘点）
     */
    @Transactional
    public MaterialBatch adjustBatch(String batchId, BigDecimal adjustmentQuantity,
                                     String adjustmentType, String reason, Integer adjustedBy) {
        MaterialBatch batch = getBatchById(batchId);

        log.info("调整批次数量: batchId={}, adjustment={}, type={}, reason={}",
                batchId, adjustmentQuantity, adjustmentType, reason);

        // 调用实体类的调整方法
        batch.adjust(adjustmentQuantity);

        // 保存批次更新
        MaterialBatch updated = batchRepository.save(batch);

        // 创建调整记录
        MaterialBatchAdjustment adjustment = new MaterialBatchAdjustment(
                batchId, adjustmentType, adjustmentQuantity, reason, adjustedBy);
        adjustmentRepository.save(adjustment);

        log.info("调整成功: batchId={}, 新剩余数量={}, 调整值={}",
                batchId, updated.getRemainingQuantity(), adjustmentQuantity);

        return updated;
    }

    /**
     * 更新批次状态
     */
    @Transactional
    public MaterialBatch updateBatchStatus(String batchId, MaterialBatch.BatchStatus newStatus) {
        MaterialBatch batch = getBatchById(batchId);

        log.info("更新批次状态: batchId={}, oldStatus={}, newStatus={}",
                batchId, batch.getStatus(), newStatus);

        batch.setStatus(newStatus);
        return batchRepository.save(batch);
    }

    // ========== FIFO库存分配 ==========

    /**
     * FIFO自动分配材料批次
     * 用于生产计划创建时，自动从最早入库的批次分配材料
     *
     * @param factoryId 工厂ID
     * @param materialTypeId 材料类型ID
     * @param requiredQuantity 需要的数量
     * @return 分配结果列表 [{batchId, quantity}, ...]
     */
    @Transactional
    public List<Map<String, Object>> allocateFifoBatches(String factoryId,
                                                          String materialTypeId,
                                                          BigDecimal requiredQuantity) {
        log.info("FIFO分配材料: factoryId={}, materialTypeId={}, required={}",
                factoryId, materialTypeId, requiredQuantity);

        // 获取FIFO排序的可用批次（按入库日期升序）
        List<MaterialBatch> fifoBatches = batchRepository.findFifoBatchesByMaterialType(factoryId, materialTypeId);

        List<Map<String, Object>> allocations = new ArrayList<>();
        BigDecimal remaining = requiredQuantity;

        for (MaterialBatch batch : fifoBatches) {
            if (remaining.compareTo(BigDecimal.ZERO) <= 0) {
                break;
            }

            // 计算该批次可分配数量（剩余数量 - 预留数量）
            BigDecimal available = batch.getAvailableQuantity();

            if (available.compareTo(BigDecimal.ZERO) <= 0) {
                continue;
            }

            // 从该批次分配
            BigDecimal allocate = remaining.min(available);

            Map<String, Object> allocation = new HashMap<>();
            allocation.put("batchId", batch.getId());
            allocation.put("batchNumber", batch.getBatchNumber());
            allocation.put("quantity", allocate);
            allocation.put("unitPrice", batch.getUnitPrice());
            allocation.put("inboundDate", batch.getInboundDate());
            allocations.add(allocation);

            remaining = remaining.subtract(allocate);
        }

        if (remaining.compareTo(BigDecimal.ZERO) > 0) {
            log.warn("FIFO分配不足: 需要={}, 剩余={}, 缺口={}",
                    requiredQuantity, requiredQuantity.subtract(remaining), remaining);
        } else {
            log.info("FIFO分配成功: 共从{}个批次分配", allocations.size());
        }

        return allocations;
    }

    /**
     * 获取指定材料类型的FIFO批次列表
     */
    public List<MaterialBatch> getFifoBatches(String factoryId, String materialTypeId, BigDecimal quantity) {
        List<MaterialBatch> fifoBatches = batchRepository.findFifoBatchesByMaterialType(factoryId, materialTypeId);

        // 只返回能满足需求的批次
        BigDecimal accumulated = BigDecimal.ZERO;
        List<MaterialBatch> result = new ArrayList<>();

        for (MaterialBatch batch : fifoBatches) {
            result.add(batch);
            accumulated = accumulated.add(batch.getAvailableQuantity());

            if (accumulated.compareTo(quantity) >= 0) {
                break;
            }
        }

        return result;
    }

    // ========== 过期管理 ==========

    /**
     * 获取即将过期的批次（N天内过期）
     */
    public List<MaterialBatch> getExpiringBatches(String factoryId, Integer days) {
        LocalDate today = LocalDate.now();
        LocalDate expiryDate = today.plusDays(days != null ? days : 7); // 默认7天

        return batchRepository.findExpiringBatches(factoryId, today, expiryDate);
    }

    /**
     * 获取已过期的批次
     */
    public List<MaterialBatch> getExpiredBatches(String factoryId) {
        return batchRepository.findExpiredBatches(factoryId, LocalDate.now());
    }

    /**
     * 自动处理过期批次（定时任务调用）
     */
    @Transactional
    public int handleExpiredBatches(String factoryId) {
        List<MaterialBatch> expiredBatches = getExpiredBatches(factoryId);

        log.info("处理过期批次: factoryId={}, count={}", factoryId, expiredBatches.size());

        int count = 0;
        for (MaterialBatch batch : expiredBatches) {
            // 标记为过期状态
            batch.markExpired();
            batchRepository.save(batch);
            count++;
        }

        log.info("过期批次处理完成: factoryId={}, 处理数量={}", factoryId, count);
        return count;
    }

    // ========== 库存统计 ==========

    /**
     * 获取工厂总库存数量
     */
    public BigDecimal getTotalInventoryQuantity(String factoryId) {
        return batchRepository.getTotalRemainingQuantity(factoryId);
    }

    /**
     * 获取工厂总库存价值
     */
    public BigDecimal getTotalInventoryValue(String factoryId) {
        return batchRepository.getTotalInventoryValue(factoryId);
    }

    /**
     * 获取指定材料类型的库存数量
     */
    public BigDecimal getInventoryQuantityByMaterialType(String factoryId, String materialTypeId) {
        return batchRepository.getTotalQuantityByMaterialType(factoryId, materialTypeId);
    }

    /**
     * 获取指定材料类型的可用数量（剩余-预留）
     */
    public BigDecimal getAvailableQuantityByMaterialType(String factoryId, String materialTypeId) {
        return batchRepository.getAvailableQuantityByMaterialType(factoryId, materialTypeId);
    }

    /**
     * 获取库存统计（按材料类型分组）
     */
    public List<Map<String, Object>> getInventoryStatistics(String factoryId) {
        List<Object[]> stats = batchRepository.getInventoryStatisticsByMaterialType(factoryId);

        return stats.stream().map(row -> {
            Map<String, Object> stat = new HashMap<>();
            stat.put("materialTypeId", row[0]);
            stat.put("batchCount", row[1]);
            stat.put("totalQuantity", row[2]);
            stat.put("totalValue", row[3]);
            return stat;
        }).collect(Collectors.toList());
    }

    /**
     * 获取库存价值统计
     */
    public Map<String, Object> getInventoryValuation(String factoryId) {
        Map<String, Object> valuation = new HashMap<>();

        BigDecimal totalQuantity = getTotalInventoryQuantity(factoryId);
        BigDecimal totalValue = getTotalInventoryValue(factoryId);

        valuation.put("totalQuantity", totalQuantity);
        valuation.put("totalValue", totalValue);
        valuation.put("batchCount", batchRepository.countByFactoryId(factoryId));

        // 按状态统计
        List<Object[]> statusStats = batchRepository.getStatisticsByStatus(factoryId);
        valuation.put("statusStatistics", statusStats.stream().map(row -> {
            Map<String, Object> stat = new HashMap<>();
            stat.put("status", row[0]);
            stat.put("count", row[1]);
            stat.put("quantity", row[2]);
            return stat;
        }).collect(Collectors.toList()));

        return valuation;
    }

    // ========== 低库存预警 ==========

    /**
     * 获取低库存批次
     */
    public List<MaterialBatch> getLowStockBatches(String factoryId, BigDecimal threshold) {
        return batchRepository.findLowStockBatches(factoryId, threshold);
    }

    /**
     * 获取低库存预警（默认阈值100）
     */
    public List<MaterialBatch> getLowStockBatches(String factoryId) {
        return getLowStockBatches(factoryId, BigDecimal.valueOf(100));
    }

    // ========== 调整记录查询 ==========

    /**
     * 获取批次的调整历史
     */
    public List<MaterialBatchAdjustment> getBatchAdjustments(String batchId) {
        return adjustmentRepository.findByMaterialBatchIdOrderByAdjustedAtDesc(batchId);
    }

    /**
     * 获取批次使用历史
     */
    public List<ProductionPlanBatchUsage> getBatchUsageHistory(String batchId) {
        return usageRepository.findByMaterialBatchId(batchId);
    }

    // ========== 供应商相关 ==========

    /**
     * 根据供应商获取批次
     */
    public List<MaterialBatch> getBatchesBySupplier(String factoryId, String supplierId) {
        return batchRepository.findByFactoryIdAndSupplierId(factoryId, supplierId);
    }

    /**
     * 统计供应商入库总量
     */
    public BigDecimal getSupplierInboundQuantity(String factoryId, String supplierId) {
        return batchRepository.getTotalInboundQuantityBySupplier(factoryId, supplierId);
    }

    // ========== 日期范围查询 ==========

    /**
     * 根据入库日期范围获取批次
     */
    public List<MaterialBatch> getBatchesByDateRange(String factoryId, LocalDate startDate, LocalDate endDate) {
        return batchRepository.findBatchesByInboundDateRange(factoryId, startDate, endDate);
    }

    /**
     * 统计日期范围内的入库总量
     */
    public BigDecimal getInboundQuantityInDateRange(String factoryId, LocalDate startDate, LocalDate endDate) {
        return batchRepository.getTotalInboundInDateRange(factoryId, startDate, endDate);
    }

    /**
     * 统计日期范围内的入库总成本
     */
    public BigDecimal getInboundCostInDateRange(String factoryId, LocalDate startDate, LocalDate endDate) {
        return batchRepository.getTotalCostInDateRange(factoryId, startDate, endDate);
    }

    // ========== 存储位置管理 ==========

    /**
     * 根据存储位置获取批次
     */
    public List<MaterialBatch> getBatchesByStorageLocation(String factoryId, String storageLocation) {
        return batchRepository.findByFactoryIdAndStorageLocation(factoryId, storageLocation);
    }
}
